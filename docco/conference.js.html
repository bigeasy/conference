<!DOCTYPE html>

<html>
<head>
  <title>conference.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

    <ul class="sections">

          <li id="title">
              <div class="annotation">
                  <h1>conference.js</h1>
              </div>
          </li>



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Common utilities.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>)
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>)

</pre></div></div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Control-flow utilities.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> abend = <span class="hljs-built_in">require</span>(<span class="hljs-string">'abend'</span>)
<span class="hljs-keyword">var</span> cadence = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cadence'</span>)


<span class="hljs-keyword">var</span> Monotonic = <span class="hljs-built_in">require</span>(<span class="hljs-string">'monotonic'</span>).asString

<span class="hljs-keyword">var</span> coalesce = <span class="hljs-built_in">require</span>(<span class="hljs-string">'nascent.coalesce'</span>)

<span class="hljs-keyword">var</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'prolific.logger'</span>).createLogger(<span class="hljs-string">'conference'</span>)
<span class="hljs-keyword">var</span> interrupt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'interrupt'</span>).createInterrupter(<span class="hljs-string">'conference'</span>)

<span class="hljs-keyword">var</span> Operation = <span class="hljs-built_in">require</span>(<span class="hljs-string">'operation'</span>)

</pre></div></div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Invoke round trip requests into an evented message queue.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Requester = <span class="hljs-built_in">require</span>(<span class="hljs-string">'conduit/requester'</span>)

</pre></div></div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Emit events into an evented message queue.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Spigot = <span class="hljs-built_in">require</span>(<span class="hljs-string">'conduit/spigot'</span>)

</pre></div></div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Respond to requests from an evented message queue.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Responder = <span class="hljs-built_in">require</span>(<span class="hljs-string">'conduit/responder'</span>)

</pre></div></div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Consume events from an evented message queue.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Basin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'conduit/basin'</span>)

</pre></div></div>

        </li>


        <li id="section-7">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>The patterns below take my back to my efforts to create immutable
constructors when immutability was all the rage in Java-land. It would have
pained me to create an object that continues to initialize the object after
the constructor, but at the same time Iâ€™d have no real problem with reponding
the headers in these streams. It was something that I abandoned after having
spend some time with it, with rationale that I cannot remember. I can only
remember the ratoinale that led me to adopt it.</p>
<p>It did lead me to consider the folly of ORM, though.</p>

            </div>

        </li>


        <li id="section-8">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>A <code>Responder</code> class specific to the Conference that will respond to
directives from a Colleague.</p>

            </div>

        </li>


        <li id="section-9">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Update: Actually, passing in the builder function feels somewhat immutable,
about as immutable as JavaScript is going to get.</p>

            </div>

        </li>


        <li id="section-10">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Constructor</span> (<span class="hljs-params">object, operations</span>) </span>{
    <span class="hljs-keyword">this</span>._object = objec
    <span class="hljs-keyword">this</span>._operations = operations
}

Constructor.prototype._setOperation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">qualifier, name, operation</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> operation == <span class="hljs-string">'string'</span>) {
        assert(<span class="hljs-keyword">this</span>._object, <span class="hljs-string">'object cannot be null'</span>)
        operation = { <span class="hljs-attr">object</span>: <span class="hljs-keyword">this</span>._object, <span class="hljs-attr">method</span>: operation }
    }
    <span class="hljs-keyword">this</span>._operations[qualifier + <span class="hljs-string">':'</span> + name] = <span class="hljs-keyword">new</span> Operation(operation)
}

Constructor.prototype.join = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(<span class="hljs-string">'internal'</span>, <span class="hljs-string">'join'</span>, coalesce(method, <span class="hljs-string">'join'</span>))
}

Constructor.prototype.immigrate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(<span class="hljs-string">'internal'</span>, <span class="hljs-string">'immigrate'</span>, coalesce(method, <span class="hljs-string">'immigrate'</span>))
}

Constructor.prototype.exile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(<span class="hljs-string">'internal'</span>, <span class="hljs-string">'exile'</span>, coalesce(method, <span class="hljs-string">'exile'</span>))
}

Constructor.prototype.receive = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(<span class="hljs-string">'receive'</span>, name, coalesce(method, name))
}

Constructor.prototype.reduced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(<span class="hljs-string">'reduced'</span>, name, coalesce(method, name))
}

Constructor.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(<span class="hljs-string">'request'</span>, name, coalesce(name, method))
}

Constructor.prototype.catalog = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(<span class="hljs-string">'catalog'</span>, name, coalesce(name, method))
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dispatcher</span> (<span class="hljs-params">conference</span>) </span>{
    <span class="hljs-keyword">this</span>._conference = conference
}

Dispatcher.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">envelope, callback</span>) </span>{
    <span class="hljs-keyword">this</span>._conference._outOfBand(envelope, callback)
}

Dispatcher.prototype.fromBasin = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">envelope, callback</span>) </span>{
    <span class="hljs-keyword">switch</span> (envelope.method) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'join'</span>:
        <span class="hljs-keyword">this</span>._conference._join(envelope.body, callback)
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'entry'</span>:
        <span class="hljs-keyword">this</span>._conference._entry(envelope.body, callback)
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'replay'</span>:
        <span class="hljs-keyword">this</span>._conference._replay(envelope.body, callback)
        <span class="hljs-keyword">break</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Conference</span> (<span class="hljs-params">object, constructor</span>) </span>{
    <span class="hljs-keyword">this</span>.isLeader = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">this</span>.colleague = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">this</span>.replaying = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">this</span>.id = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">this</span>._cookie = <span class="hljs-string">'0'</span>
    <span class="hljs-keyword">this</span>._broadcasts = {}
    <span class="hljs-keyword">this</span>._backlogs = {}

</pre></div></div>

        </li>


        <li id="section-11">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Currently exposed for testing, but feeling that these method should be
public for general testing, with one wrapper that hooks it up to the
colleagueâ€™s streams and another that lets you send mock events.</p>

            </div>

        </li>


        <li id="section-12">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._dispatcher = <span class="hljs-keyword">new</span> Dispatcher(<span class="hljs-keyword">this</span>)

</pre></div></div>

        </li>


        <li id="section-13">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Events go first through a <code>Responder</code> which will invoke our out of band
method and return the result. If the message is not an out of band
requests it is a message that does not expect a response. It will flow
into the <code>Basin</code> where weâ€™ll dispatch it and send to response.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> responder = <span class="hljs-keyword">new</span> Responder(<span class="hljs-keyword">this</span>._dispatcher, <span class="hljs-string">'conference'</span>)
    <span class="hljs-keyword">var</span> basin = <span class="hljs-keyword">new</span> Basin(<span class="hljs-keyword">this</span>._dispatcher)

    responder.spigot.emptyInto(basin)

</pre></div></div>

        </li>


        <li id="section-14">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>The basin into which events flow form the network.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.basin = responder.basin

</pre></div></div>

        </li>


        <li id="section-15">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Round trip events used to perform requests for out-of-band data.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._requester = <span class="hljs-keyword">new</span> Requester(<span class="hljs-string">'conference'</span>)
    <span class="hljs-keyword">this</span>.spigot = <span class="hljs-keyword">this</span>._requester.spigo

</pre></div></div>

        </li>


        <li id="section-16">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>An internal spigot that flows thorugh the requester used to publish and
record.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._spigot = <span class="hljs-keyword">new</span> Spigot(<span class="hljs-keyword">this</span>._dispatcher)
    <span class="hljs-keyword">this</span>._spigot.emptyInto(<span class="hljs-keyword">this</span>._requester.basin)

    <span class="hljs-keyword">constructor</span>(new Constructor(object, this._operations = {}))
}

</pre></div></div>

        </li>


        <li id="section-17">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>An ever increasing identify to adorn our broadcasts so that itâ€™s key will be
unique when we combine our immigration promise with the cookie.</p>

            </div>

        </li>


        <li id="section-18">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype._nextCookie = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._cookie = Monotonic.increment(<span class="hljs-keyword">this</span>._cookie, <span class="hljs-number">0</span>)
}

</pre></div></div>

        </li>


        <li id="section-19">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Run the given operation if we are not replaying a log. If we are no
replaying then we are performing actions that generate out-of-band log
entries. If we are replaying we want to replay those out-of-band log entries.</p>

            </div>

        </li>


        <li id="section-20">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype.ifNotReplaying = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, operation</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.replaying) {
        <span class="hljs-keyword">new</span> Operation(operation).apply([ <span class="hljs-keyword">async</span>() ])
    }
})

</pre></div></div>

        </li>


        <li id="section-21">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>TODO Why sometimes wait? I donâ€™t want to wait on naturalized. Iâ€™m assuming
that weâ€™re not going to publish much, and that weâ€™re not going to wait for
the queue to empty. We donâ€™t have back-pressure and if we did have
back-pressure, we would have deadlock. We should push, not enqueue.</p>

            </div>

        </li>


        <li id="section-22">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype.naturalized = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._spigot.requests.push({
        <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
        <span class="hljs-attr">method</span>: <span class="hljs-string">'naturalized'</span>,
        <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span>
    })
}

</pre></div></div>

        </li>


        <li id="section-23">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Get the properties for a particular id or promise.</p>

            </div>

        </li>


        <li id="section-24">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype.getProperties = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
    id = coalesce(<span class="hljs-keyword">this</span>.government.immigrated.id[id], id)
    <span class="hljs-keyword">return</span> coalesce(<span class="hljs-keyword">this</span>.government.properties[id])
}

</pre></div></div>

        </li>


        <li id="section-25">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Respond an out of band request. If you want to return a status code you can
just throw the integer value.</p>
<p>Not sure if I want to use UNIX codes or HTTP status codes. Leaning toward
HTTP status codes and throwing them as integer.</p>

            </div>

        </li>


        <li id="section-26">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype._outOfBand = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, envelope</span>) </span>{
    <span class="hljs-keyword">switch</span> (envelope.method) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'outOfBand'</span>:
        envelope = envelope.body
        <span class="hljs-keyword">this</span>._operate(<span class="hljs-string">'request'</span>, envelope.method, [ envelope.body ], <span class="hljs-keyword">async</span>())
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'backlog'</span>:
        <span class="hljs-keyword">return</span> [ coalesce(<span class="hljs-keyword">this</span>._backlogs[envelope.from]) ]
    }
})

Conference.prototype._getOperation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">qualifier, name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._operations[qualifier + <span class="hljs-string">':'</span> + name]
}

Conference.prototype._operate = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, qualifier, method, vargs</span>) </span>{
    <span class="hljs-keyword">var</span> operation = <span class="hljs-keyword">this</span>._getOperation(qualifier, method)
    <span class="hljs-keyword">if</span> (operation == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    }
    operation.apply(vargs.concat(<span class="hljs-keyword">async</span>()))
})

Conference.prototype._join = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, join</span>) </span>{
    <span class="hljs-keyword">this</span>.replaying = join.replaying
    <span class="hljs-keyword">this</span>.id = join.id
    <span class="hljs-keyword">this</span>._operate(<span class="hljs-string">'internal'</span>, <span class="hljs-string">'join'</span>, [ <span class="hljs-keyword">this</span> ], <span class="hljs-keyword">async</span>())
})

Conference.prototype._getBacklog = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{
    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._requester.request(<span class="hljs-string">'conference'</span>, {
            <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
            <span class="hljs-attr">method</span>: <span class="hljs-string">'backlog'</span>,
            <span class="hljs-attr">to</span>: <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>],
            <span class="hljs-attr">from</span>: <span class="hljs-keyword">this</span>.government.promise,
            <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span>
        }, <span class="hljs-string">'conference'</span>, <span class="hljs-keyword">async</span>())
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">broadcasts</span>) </span>{
        <span class="hljs-keyword">var</span> entries = []
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> broadcasts) {
            <span class="hljs-keyword">var</span> broadcast = broadcasts[key]
            entries.push({
                <span class="hljs-attr">body</span>: {
                    <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
                    <span class="hljs-attr">method</span>: <span class="hljs-string">'broadcast'</span>,
                    <span class="hljs-attr">key</span>: key,
                    <span class="hljs-attr">body</span>: {
                        <span class="hljs-attr">method</span>: broadcast.method,
                        <span class="hljs-attr">body</span>: broadcast.reques
                    }
                }
            })
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> promise <span class="hljs-keyword">in</span> broadcast.responses) {
                entries.push({
                    <span class="hljs-attr">body</span>: {
                        <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
                        <span class="hljs-attr">method</span>: <span class="hljs-string">'reduce'</span>,
                        <span class="hljs-attr">from</span>: promise,
                        <span class="hljs-attr">key</span>: key,
                        <span class="hljs-attr">body</span>: broadcast.responses[promise]
                    }
                })
            }
        }
        <span class="hljs-keyword">async</span>.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entry</span>) </span>{
            <span class="hljs-keyword">this</span>._entry(entry, <span class="hljs-keyword">async</span>())
        })(entries)
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</pre></div></div>

        </li>


        <li id="section-27">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>TODO Probably not a bad idea, but what was I thinking?</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._spigot.requests.push({
            <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
            <span class="hljs-attr">method</span>: <span class="hljs-string">'naturalized'</span>,
            <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span>
        })
    })
})

Conference.prototype._entry = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, entry</span>) </span>{
    <span class="hljs-keyword">if</span> (entry.government) {
        <span class="hljs-keyword">this</span>.government = entry.body
        <span class="hljs-keyword">this</span>.isLeader = <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>] == <span class="hljs-keyword">this</span>.id
        <span class="hljs-keyword">var</span> properties = entry.properties, immigran
        <span class="hljs-keyword">if</span> (immigrant = <span class="hljs-keyword">this</span>.government.immigrant) {
            <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>._operate(<span class="hljs-string">'internal'</span>, <span class="hljs-string">'immigrate'</span>, [ <span class="hljs-keyword">this</span>.government.immigrant.id ], <span class="hljs-keyword">async</span>())
            }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (immigrant.id != <span class="hljs-keyword">this</span>.id) {
                    <span class="hljs-keyword">this</span>._backlogs[<span class="hljs-keyword">this</span>.government.promise] = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>._broadcasts))
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.promise != <span class="hljs-string">'1/0'</span>) {
                    <span class="hljs-keyword">this</span>._getBacklog(<span class="hljs-keyword">async</span>())
                }
            })
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.exile) {
            <span class="hljs-keyword">var</span> exile = <span class="hljs-keyword">this</span>.government.exile
            <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>._operate(<span class="hljs-string">'internal'</span>, <span class="hljs-string">'exile'</span>, [ exile.id, exile.promise, exile.properties ], <span class="hljs-keyword">async</span>())
            }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">this</span>.government.exile.promise
                <span class="hljs-keyword">var</span> broadcasts = []
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>._broadcasts) {
                    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._broadcasts[key].responses[promise]
                    broadcasts.push(<span class="hljs-keyword">this</span>._broadcasts[key])
                }
                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._backlogs[promise]
                <span class="hljs-keyword">async</span>.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">broadcast</span>) </span>{
                    <span class="hljs-keyword">this</span>._checkReduced(broadcast, <span class="hljs-keyword">async</span>())
                })(broadcasts)
            })
        }
    } <span class="hljs-keyword">else</span> {
</pre></div></div>

        </li>


        <li id="section-28">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Reminder that if you ever want to do queued instead async then the
queue should be external and a property of the object the conference
operates.</p>

            </div>

        </li>


        <li id="section-29">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> envelope = entry.body
        <span class="hljs-keyword">switch</span> (envelope.method) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'broadcast'</span>:
            <span class="hljs-keyword">this</span>._broadcasts[envelope.key] = {
                <span class="hljs-attr">key</span>: envelope.key,
                <span class="hljs-attr">method</span>: envelope.body.method,
                <span class="hljs-attr">request</span>: envelope.body.body,
                <span class="hljs-attr">responses</span>: {}
            }
            <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>._operate(<span class="hljs-string">'receive'</span>, envelope.body.method, [ envelope.body.body ], <span class="hljs-keyword">async</span>())
            }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
                <span class="hljs-keyword">this</span>._spigot.requests.push({
                    <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
                    <span class="hljs-attr">method</span>: <span class="hljs-string">'reduce'</span>,
                    <span class="hljs-attr">from</span>: <span class="hljs-keyword">this</span>.government.immigrated.promise[<span class="hljs-keyword">this</span>.id],
                    <span class="hljs-attr">key</span>: envelope.key,
                    <span class="hljs-attr">body</span>: response
                })
            })
            <span class="hljs-keyword">break</span>
</pre></div></div>

        </li>


        <li id="section-30">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Tally our responses and if they match the number of participants,
then invoke the reduction method.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">case</span> <span class="hljs-string">'reduce'</span>:
            <span class="hljs-keyword">var</span> broadcast = <span class="hljs-keyword">this</span>._broadcasts[envelope.key]

            broadcast.responses[envelope.from] = envelope.body


            <span class="hljs-keyword">this</span>._checkReduced(broadcast, <span class="hljs-keyword">async</span>())

            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-string">'naturalized'</span>:
            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._backlogs[envelope.from]
            <span class="hljs-keyword">break</span>
        }
    }
})

Conference.prototype._checkReduced = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, broadcast</span>) </span>{
    <span class="hljs-keyword">var</span> complete = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> promise <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.government.immigrated.id) {
        <span class="hljs-keyword">if</span> (!(promise <span class="hljs-keyword">in</span> broadcast.responses)) {
            complete = <span class="hljs-literal">false</span>
            <span class="hljs-keyword">break</span>
        }
    }

    <span class="hljs-keyword">if</span> (complete) {
        <span class="hljs-keyword">var</span> reduced = []
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> promise <span class="hljs-keyword">in</span> broadcast.responses) {
            reduced.push({
                <span class="hljs-attr">id</span>: <span class="hljs-keyword">this</span>.government.immigrated.id[promise],
                <span class="hljs-attr">value</span>: broadcast.responses[promise]
            })
        }
        <span class="hljs-keyword">this</span>._operate(<span class="hljs-string">'reduced'</span>, broadcast.method, [ reduced, broadcast.request ], <span class="hljs-keyword">async</span>())
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._broadcasts[broadcast.key]
    }
})

</pre></div></div>

        </li>


        <li id="section-31">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>TODO Save welcomes, or introductions, and have them expire when the welcome
expires, and maybe that is the entirety of out-of-band.</p>

            </div>

        </li>


        <li id="section-32">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype.outOfBand = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, to, method, body</span>) </span>{
    <span class="hljs-keyword">this</span>._requester.request(<span class="hljs-string">'conference'</span>, {
</pre></div></div>

        </li>


        <li id="section-33">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Do not think it odd that this is nested and <code>&#39;backlog&#39;</code> is not.
It reflects that one is system internal and the other is four our
dear user.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-built_in">module</span>: <span class="hljs-string">'conference'</span>,
        <span class="hljs-attr">method</span>: <span class="hljs-string">'outOfBand'</span>,
        <span class="hljs-attr">body</span>: {
            <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
            <span class="hljs-attr">method</span>: method,
            <span class="hljs-attr">to</span>: <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>],
            <span class="hljs-attr">from</span>: <span class="hljs-keyword">this</span>.government.promise,
            <span class="hljs-attr">body</span>: body
        }
    }, <span class="hljs-keyword">async</span>())
})

</pre></div></div>

        </li>


        <li id="section-34">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Note that we donâ€™t wait on enqueuing the request, but we do wait on replay.
Replay is independent of the consensus algorithm.</p>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype.record = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, method, message</span>) </span>{
    <span class="hljs-keyword">this</span>._spigot.requests.push({
        <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
        <span class="hljs-attr">method</span>: <span class="hljs-string">'record'</span>,
        <span class="hljs-attr">body</span>: {
            <span class="hljs-attr">method</span>: method,
            <span class="hljs-attr">body</span>: message
        }
    })
    <span class="hljs-keyword">this</span>._replay({ <span class="hljs-attr">method</span>: method, <span class="hljs-attr">body</span>: message }, <span class="hljs-keyword">async</span>())
})

Conference.prototype._replay = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, record</span>) </span>{
    <span class="hljs-keyword">this</span>._operate(<span class="hljs-string">'catalog'</span>, record.method, [ record.body ], <span class="hljs-keyword">async</span>())
})

</pre></div></div>

        </li>


        <li id="section-35">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Honoring back pressure here, but Iâ€™ve not considered if back pressure is
going to cause deadlock. Iâ€™m sure it can. What happens when the queues
between the parcipants fill?</p>

            </div>

        </li>


        <li id="section-36">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>This bit of code here is disconcerting because it indicates an asynchronous
call back into the system that is waiting for it to complete. At first, I
want to make this call synchronous because we do not want block here.
However, there is still error reporting. We can implement <code>publish</code> so tha
it doesnâ€™t necessarily block, give real thought to how we should deal with
stream overflow, and keep a consistent interface. Weâ€™re going to decide tha
a high-water mark is unrecoverable, so this call would return an error, and
that error will crash this participant.</p>

            </div>

        </li>


        <li id="section-37">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype.broadcast = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method, message</span>) </span>{
    <span class="hljs-keyword">var</span> cookie = <span class="hljs-keyword">this</span>._nextCookie()
    <span class="hljs-keyword">var</span> uniqueId = <span class="hljs-keyword">this</span>.government.immigrated.promise[<span class="hljs-keyword">this</span>.id]
    <span class="hljs-keyword">var</span> key = method + <span class="hljs-string">'['</span> + uniqueId + <span class="hljs-string">']('</span> + cookie + <span class="hljs-string">')'</span>
    <span class="hljs-keyword">this</span>._spigot.requests.push({
        <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
        <span class="hljs-attr">method</span>: <span class="hljs-string">'broadcast'</span>,
        <span class="hljs-attr">key</span>: key,
        <span class="hljs-attr">body</span>: {
            <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
            <span class="hljs-attr">method</span>: method,
            <span class="hljs-attr">body</span>: message
        }
    })
}

<span class="hljs-built_in">module</span>.exports = Conference

</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
