<!DOCTYPE html>

<html>
<head>
  <title>conference.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

    <ul class="sections">

          <li id="title">
              <div class="annotation">
                  <h1>conference.js</h1>
              </div>
          </li>



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Common utilities.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>)
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>)
<span class="hljs-keyword">var</span> coalesce = <span class="hljs-built_in">require</span>(<span class="hljs-string">'extant'</span>)</pre></div></div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Control-flow utilities.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> cadence = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cadence'</span>)

<span class="hljs-keyword">var</span> Cliffhanger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cliffhanger'</span>)

<span class="hljs-keyword">var</span> Procession = <span class="hljs-built_in">require</span>(<span class="hljs-string">'procession'</span>)

<span class="hljs-keyword">var</span> Monotonic = <span class="hljs-built_in">require</span>(<span class="hljs-string">'monotonic'</span>).asString

<span class="hljs-keyword">var</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'prolific.logger'</span>).createLogger(<span class="hljs-string">'conference'</span>)

<span class="hljs-keyword">var</span> Operation = <span class="hljs-built_in">require</span>(<span class="hljs-string">'operation/redux'</span>)</pre></div></div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Invoke round trip requests into an evented message queue.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Requester = <span class="hljs-built_in">require</span>(<span class="hljs-string">'conduit/requester'</span>)</pre></div></div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Respond to requests from an evented message queue.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Responder = <span class="hljs-built_in">require</span>(<span class="hljs-string">'conduit/responder'</span>)

<span class="hljs-keyword">var</span> Client = <span class="hljs-built_in">require</span>(<span class="hljs-string">'conduit/client'</span>)
<span class="hljs-keyword">var</span> Server = <span class="hljs-built_in">require</span>(<span class="hljs-string">'conduit/server'</span>)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">keyify</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)) }</pre></div></div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>The patterns below take my back to my efforts to create immutable
constructors when immutability was all the rage in Java-land. It would have
pained me to create an object that continues to initialize the object after
the constructor, but at the same time Iâ€™d have no real problem with reponding
the headers in these streams. It was something that I abandoned after having
spend some time with it, with rationale that I cannot remember. I can only
remember the ratoinale that led me to adopt it.</p>
<p>It did lead me to consider the folly of ORM, though.</p>

            </div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>A <code>Responder</code> class specific to the Conference that will respond to
directives from a Colleague.</p>

            </div>

        </li>


        <li id="section-7">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Update: Actually, passing in the builder function feels somewhat immutable,
about as immutable as JavaScript is going to get.</p>

            </div>

        </li>


        <li id="section-8">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Constructor</span> (<span class="hljs-params">conference, properties, object, operations</span>) </span>{
    <span class="hljs-keyword">this</span>._object = object
    <span class="hljs-keyword">this</span>._operations = operations
    <span class="hljs-keyword">this</span>._properties = properties
    <span class="hljs-keyword">this</span>._setOperation(keyify(<span class="hljs-literal">true</span>, <span class="hljs-string">'receive'</span>, <span class="hljs-string">'naturalized'</span>), { <span class="hljs-attr">object</span>: conference, <span class="hljs-attr">method</span>: <span class="hljs-string">'_naturalized'</span> })
    <span class="hljs-keyword">this</span>._setOperation(keyify(<span class="hljs-literal">true</span>, <span class="hljs-string">'request'</span>, <span class="hljs-string">'backlog'</span>), { <span class="hljs-attr">object</span>: conference, <span class="hljs-attr">method</span>: <span class="hljs-string">'_backlog'</span> })
}

Constructor.prototype._setOperation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, operation</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> operation == <span class="hljs-string">'string'</span>) {
        assert(<span class="hljs-keyword">this</span>._object, <span class="hljs-string">'object cannot be null'</span>)
        operation = { <span class="hljs-attr">object</span>: <span class="hljs-keyword">this</span>._object, <span class="hljs-attr">method</span>: operation }
    }
    <span class="hljs-keyword">this</span>._operations[key] = Operation(operation)
}

Constructor.prototype.setProperty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>{
    <span class="hljs-keyword">this</span>._properties[name] = value
}

Constructor.prototype.setProperties = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">properties</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> properties) {
        <span class="hljs-keyword">this</span>._properties[name] = properties[name]
    }
}

Constructor.prototype.bootstrap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(keyify(<span class="hljs-string">'bootstrap'</span>), coalesce(method, <span class="hljs-string">'bootstrap'</span>))
}

Constructor.prototype.join = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(keyify(<span class="hljs-string">'join'</span>), coalesce(method, <span class="hljs-string">'join'</span>))
}

Constructor.prototype.immigrate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(keyify(<span class="hljs-string">'immigrate'</span>), coalesce(method, <span class="hljs-string">'immigrate'</span>))
}

Constructor.prototype.naturalized = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(keyify(<span class="hljs-string">'naturalized'</span>), coalesce(method, <span class="hljs-string">'naturalized'</span>))
}

Constructor.prototype.exile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(keyify(<span class="hljs-string">'exile'</span>), coalesce(method, <span class="hljs-string">'exile'</span>))
}

Constructor.prototype.government = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(keyify(<span class="hljs-string">'government'</span>), coalesce(method, <span class="hljs-string">'government'</span>))
}

Constructor.prototype.receive = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(keyify(<span class="hljs-literal">false</span>, <span class="hljs-string">'receive'</span>, name), coalesce(method, name))
}

Constructor.prototype.reduced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(keyify(<span class="hljs-literal">false</span>, <span class="hljs-string">'reduced'</span>, name), coalesce(method, name))
}

Constructor.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(keyify(<span class="hljs-literal">false</span>, <span class="hljs-string">'request'</span>, name), coalesce(name, method))
}

Constructor.prototype.socket = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(keyify(<span class="hljs-string">'socket'</span>), coalesce(method, <span class="hljs-string">'socket'</span>))
}

Constructor.prototype.method = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, method</span>) </span>{
    <span class="hljs-keyword">this</span>._setOperation(keyify(<span class="hljs-string">'method'</span>, name), coalesce(name, method))
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dispatcher</span> (<span class="hljs-params">conference</span>) </span>{
    <span class="hljs-keyword">this</span>._conference = conference
}

Dispatcher.prototype.request = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, envelope</span>) </span>{
    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>._conference._request(envelope, <span class="hljs-keyword">async</span>())
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
        <span class="hljs-keyword">return</span> [ response ]
    })
})

Dispatcher.prototype.fromBasin = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">envelope, callback</span>) </span>{
    <span class="hljs-keyword">this</span>._conference._fromBasin(envelope, callback)
}

Dispatcher.prototype.fromSpigot = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">envelope, callback</span>) </span>{
    <span class="hljs-keyword">this</span>._conference._fromSpigot(envelope, callback)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Conference</span> (<span class="hljs-params">object, constructor</span>) </span>{
    logger.info(<span class="hljs-string">'constructed'</span>, {})
    <span class="hljs-keyword">this</span>.isLeader = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">this</span>.colleague = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">this</span>.replaying = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">this</span>.id = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">this</span>._cookie = <span class="hljs-string">'0'</span>
    <span class="hljs-keyword">this</span>._boundary = <span class="hljs-string">'0'</span>
    <span class="hljs-keyword">this</span>._broadcasts = {}
    <span class="hljs-keyword">this</span>._backlogs = {}

    <span class="hljs-keyword">this</span>._records = <span class="hljs-keyword">new</span> Procession
    <span class="hljs-keyword">this</span>._replays = <span class="hljs-keyword">this</span>._records.shifter()</pre></div></div>

        </li>


        <li id="section-9">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Currently exposed for testing, but feeling that these method should be
public for general testing, with one wrapper that hooks it up to the
colleagueâ€™s streams and another that lets you send mock events.</p>

            </div>

        </li>


        <li id="section-10">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._dispatcher = <span class="hljs-keyword">new</span> Dispatcher(<span class="hljs-keyword">this</span>)

    <span class="hljs-keyword">this</span>.read = <span class="hljs-keyword">new</span> Procession
    <span class="hljs-keyword">this</span>.write = <span class="hljs-keyword">new</span> Procession

    <span class="hljs-keyword">this</span>._client = <span class="hljs-keyword">new</span> Client(<span class="hljs-string">'outgoing'</span>, <span class="hljs-keyword">this</span>.write, <span class="hljs-keyword">this</span>.read)
    <span class="hljs-keyword">var</span> server = <span class="hljs-keyword">new</span> Server({ <span class="hljs-attr">object</span>: <span class="hljs-keyword">this</span>, <span class="hljs-attr">method</span>: <span class="hljs-string">'_connect'</span> }, <span class="hljs-string">'incoming'</span>, <span class="hljs-keyword">this</span>._client.read, <span class="hljs-keyword">this</span>._client.write)
    <span class="hljs-keyword">var</span> responder = <span class="hljs-keyword">new</span> Responder(<span class="hljs-keyword">this</span>._dispatcher, <span class="hljs-string">'colleague'</span>, server.read, server.write)
    <span class="hljs-keyword">this</span>._requester = <span class="hljs-keyword">new</span> Requester(<span class="hljs-string">'colleague'</span>, responder.read, responder.write)

    <span class="hljs-keyword">this</span>._write = <span class="hljs-keyword">this</span>._requester.write
    <span class="hljs-keyword">this</span>._requester.read.pump([ <span class="hljs-keyword">this</span>, <span class="hljs-string">'_entry'</span> ])
    <span class="hljs-keyword">this</span>._requester.read.pump([ <span class="hljs-keyword">this</span>, <span class="hljs-string">'_play'</span> ])

    <span class="hljs-keyword">this</span>._cliffhanger = <span class="hljs-keyword">new</span> Cliffhanger

    <span class="hljs-keyword">constructor</span>(new Constructor(this, this._properties = {}, object, <span class="hljs-keyword">this</span>._operations = {}))
}</pre></div></div>

        </li>


        <li id="section-11">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>An ever increasing identify to adorn our broadcasts so that itâ€™s key will be
unique when we combine our immigration promise with the cookie.</p>

            </div>

        </li>


        <li id="section-12">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype._nextCookie = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._cookie = Monotonic.increment(<span class="hljs-keyword">this</span>._cookie, <span class="hljs-number">0</span>)
}

Conference.prototype._nextBoundary = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._boundary = Monotonic.increment(<span class="hljs-keyword">this</span>._boundary, <span class="hljs-number">0</span>)
}

Conference.prototype._play = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, envelope</span>) </span>{
    <span class="hljs-keyword">if</span> (envelope == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">switch</span> (envelope.method) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'record'</span>:
        <span class="hljs-keyword">this</span>._records.enqueue(envelope, <span class="hljs-keyword">async</span>())
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'invoke'</span>:
        <span class="hljs-keyword">this</span>._invoke(envelope.body.method, envelope.body.body, <span class="hljs-keyword">async</span>())
        <span class="hljs-keyword">break</span>
    }
})

Conference.prototype._entries = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, envelope</span>) </span>{
    <span class="hljs-keyword">if</span> (envelope == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">switch</span> (envelope.method) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'entry'</span>:
        <span class="hljs-keyword">this</span>._write.push({
            <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
            <span class="hljs-attr">method</span>: <span class="hljs-string">'boundary'</span>,
            <span class="hljs-attr">id</span>: <span class="hljs-keyword">this</span>._nextBoundary(),
            <span class="hljs-attr">entry</span>: envelope.body.promise
        })
        <span class="hljs-keyword">this</span>._entry(envelope.body, <span class="hljs-keyword">async</span>())
        <span class="hljs-keyword">break</span>
    }
})</pre></div></div>

        </li>


        <li id="section-13">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Run the given operation if we are not replaying a log. If we are not
replaying then we are performing actions that generate out-of-band log
entries. If we are replaying we want to replay those out-of-band log entries.</p>

            </div>

        </li>


        <li id="section-14">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype._ifNotReplaying = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, operation</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.replaying) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-number">1</span>)
    }
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.replaying) {
        Operation(operation)(<span class="hljs-keyword">async</span>())
    }
})

Conference.prototype.ifNotReplaying = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.boundary()
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length == <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">this</span>._ifNotReplaying(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>])
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> <span class="hljs-keyword">async</span> = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], conference = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (!conference.replaying) {
                <span class="hljs-keyword">async</span>.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>))
            }
        }
    }
}

Conference.prototype._record_ = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, operation</span>) </span>{
    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> id = <span class="hljs-keyword">this</span>._boundary = Monotonic.increment(<span class="hljs-keyword">this</span>._boundary, <span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> (conference.replaying) {
            <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>._records.dequeue(<span class="hljs-keyword">async</span>())
            }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">envelope</span>) </span>{
                assert(envelope.id == envelope.id)
                <span class="hljs-keyword">return</span> envelope.body
            })
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">async</span>.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>))
        }
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
        result = coalesce(result)
        <span class="hljs-keyword">this</span>._write.push({
            <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
            <span class="hljs-attr">method</span>: <span class="hljs-string">'record'</span>,
            <span class="hljs-attr">id</span>: id,
            <span class="hljs-attr">body</span>: result
        })
        <span class="hljs-keyword">return</span> [ result ]
    })
})

Conference.prototype.record_ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length == <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">this</span>._record_(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>])
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> <span class="hljs-keyword">async</span> = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>], conference = <span class="hljs-keyword">this</span>
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> id = conference._nextBoundary()
            <span class="hljs-keyword">var</span> steps = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)
            <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (conference.replaying) {
                    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                        conference._replays.dequeue(<span class="hljs-keyword">async</span>())
                    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">envelope</span>) </span>{
                        assert(envelope.id == envelope.id)
                        <span class="hljs-keyword">return</span> envelope.body
                    })
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">async</span>.apply(<span class="hljs-literal">null</span>, steps)
                }
            }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
                result = coalesce(result)
                conference._write.push({
                    <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
                    <span class="hljs-attr">method</span>: <span class="hljs-string">'record'</span>,
                    <span class="hljs-attr">id</span>: id,
                    <span class="hljs-attr">body</span>: result
                })
                <span class="hljs-keyword">return</span> [ result ]
            })
        }
    }
}

Conference.prototype.boundary = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._write.push({
        <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
        <span class="hljs-attr">method</span>: <span class="hljs-string">'boundary'</span>,
        <span class="hljs-attr">id</span>: <span class="hljs-keyword">this</span>._boundary = Monotonic.increment(<span class="hljs-keyword">this</span>._boundary, <span class="hljs-number">0</span>),
        <span class="hljs-attr">entry</span>: <span class="hljs-literal">null</span>
    })
}

Conference.prototype._invoke = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, method, body</span>) </span>{
    <span class="hljs-keyword">this</span>._write.push({
        <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
        <span class="hljs-attr">method</span>: <span class="hljs-string">'invoke'</span>,
        <span class="hljs-attr">body</span>: { <span class="hljs-attr">method</span>: method, <span class="hljs-attr">body</span>: coalesce(body) }
    })
    <span class="hljs-keyword">this</span>._operate(keyify(<span class="hljs-string">'method'</span>, method), [ <span class="hljs-keyword">this</span>, body ], <span class="hljs-keyword">async</span>())
})

Conference.prototype.invoke = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method, message, callback</span>) </span>{
    <span class="hljs-keyword">this</span>._invoke(<span class="hljs-literal">false</span>, method, message, callback)
}</pre></div></div>

        </li>


        <li id="section-15">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Get the properties for a particular id or promise.</p>

            </div>

        </li>


        <li id="section-16">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype.getProperties = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>{
    id = coalesce(<span class="hljs-keyword">this</span>.government.immigrated.id[id], id)
    <span class="hljs-keyword">return</span> coalesce(<span class="hljs-keyword">this</span>.government.properties[id])
}</pre></div></div>

        </li>


        <li id="section-17">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Respond an out of band request. If you want to return a status code you can
just throw the integer value.</p>
<p>Not sure if I want to use UNIX codes or HTTP status codes. Leaning toward
HTTP status codes and throwing them as integer.</p>

            </div>

        </li>


        <li id="section-18">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype._request = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, envelope</span>) </span>{
    <span class="hljs-keyword">switch</span> (envelope.method) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'properties'</span>:
        <span class="hljs-keyword">this</span>.id = envelope.body.id
        <span class="hljs-keyword">this</span>.replaying = envelope.body.replaying
        <span class="hljs-keyword">return</span> [ <span class="hljs-keyword">this</span>._properties ]
    <span class="hljs-keyword">case</span> <span class="hljs-string">'outOfBand'</span>:
        envelope = envelope.body
        <span class="hljs-keyword">this</span>._operate(keyify(envelope.internal, <span class="hljs-string">'request'</span>, envelope.method), [ <span class="hljs-keyword">this</span>, envelope.body ], <span class="hljs-keyword">async</span>())
        <span class="hljs-keyword">break</span>
    }
})

Conference.prototype._connect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">socket, envelope</span>) </span>{
    <span class="hljs-keyword">var</span> operation = <span class="hljs-keyword">this</span>._operations[keyify(<span class="hljs-string">'socket'</span>)]
    assert(operation != <span class="hljs-literal">null</span>)
    operation(<span class="hljs-keyword">this</span>, socket, envelope)
}

Conference.prototype._backlog = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, conference, promise</span>) </span>{
    <span class="hljs-keyword">return</span> [ <span class="hljs-keyword">this</span>._backlogs[promise] ]
})

Conference.prototype._operate = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, key, vargs</span>) </span>{
    <span class="hljs-keyword">var</span> operation = <span class="hljs-keyword">this</span>._operations[key]
    <span class="hljs-keyword">if</span> (operation == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    }
    operation.apply(<span class="hljs-literal">null</span>, vargs.concat(<span class="hljs-keyword">async</span>()))
})

Conference.prototype._getBacklog = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async</span>) </span>{
    <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'GETTING BROADCASTS'</span>)
        <span class="hljs-keyword">this</span>.record_(<span class="hljs-keyword">async</span>)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>._requester.request(<span class="hljs-string">'colleague'</span>, {
                <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
                <span class="hljs-attr">method</span>: <span class="hljs-string">'outOfBand'</span>,
                <span class="hljs-attr">to</span>: <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>],
                <span class="hljs-attr">body</span>: {
                    <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
                    <span class="hljs-attr">method</span>: <span class="hljs-string">'backlog'</span>,
                    <span class="hljs-attr">internal</span>: <span class="hljs-literal">true</span>,
                    <span class="hljs-attr">body</span>: <span class="hljs-keyword">this</span>.government.promise
                }
            }, <span class="hljs-keyword">async</span>())
        })
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">broadcasts</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'GOT BROADCASTS!!!'</span>, broadcasts)
        <span class="hljs-keyword">var</span> entries = []
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> broadcasts) {
            <span class="hljs-keyword">var</span> broadcast = broadcasts[key]
            entries.push({
                <span class="hljs-attr">body</span>: {
                    <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
                    <span class="hljs-attr">method</span>: <span class="hljs-string">'broadcast'</span>,
                    <span class="hljs-attr">key</span>: key,
                    <span class="hljs-attr">body</span>: {
                        <span class="hljs-attr">method</span>: broadcast.method,
                        <span class="hljs-attr">body</span>: broadcast.request
                    }
                }
            })
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> promise <span class="hljs-keyword">in</span> broadcast.responses) {
                entries.push({
                    <span class="hljs-attr">body</span>: {
                        <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
                        <span class="hljs-attr">method</span>: <span class="hljs-string">'reduce'</span>,
                        <span class="hljs-attr">from</span>: promise,
                        <span class="hljs-attr">key</span>: key,
                        <span class="hljs-attr">body</span>: broadcast.responses[promise]
                    }
                })
            }
        }
        <span class="hljs-keyword">async</span>.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entry</span>) </span>{
            <span class="hljs-keyword">this</span>._entry({ <span class="hljs-attr">module</span>: <span class="hljs-string">'colleague'</span>, <span class="hljs-attr">method</span>: <span class="hljs-string">'entry'</span>, <span class="hljs-attr">body</span>: entry }, <span class="hljs-keyword">async</span>())
        })(entries)
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>

        </li>


        <li id="section-19">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>TODO Probably not a bad idea, but what was I thinking?</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'trying to notify??'</span>)
        <span class="hljs-keyword">this</span>._write.push({
            <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
            <span class="hljs-attr">method</span>: <span class="hljs-string">'naturalized'</span>,
            <span class="hljs-attr">body</span>: <span class="hljs-literal">null</span>
        })
    })
})

Conference.prototype._naturalized = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, conference, promise</span>) </span>{
    <span class="hljs-keyword">this</span>._operate(keyify(<span class="hljs-string">'naturalized'</span>), [ <span class="hljs-keyword">this</span>, promise ], <span class="hljs-keyword">async</span>())
})

Conference.prototype._entry = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, envelope</span>) </span>{
    <span class="hljs-keyword">if</span> (envelope == <span class="hljs-literal">null</span> || envelope.method != <span class="hljs-string">'entry'</span>) {
        <span class="hljs-keyword">return</span> []
    }
    <span class="hljs-keyword">var</span> entry = envelope.body
    <span class="hljs-keyword">this</span>._write.push({
        <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
        <span class="hljs-attr">method</span>: <span class="hljs-string">'boundary'</span>,
        <span class="hljs-attr">id</span>: <span class="hljs-keyword">this</span>._nextBoundary(),
        <span class="hljs-attr">entry</span>: entry.promise
    })
    <span class="hljs-keyword">if</span> (entry.method == <span class="hljs-string">'government'</span>) {
        <span class="hljs-keyword">this</span>.government = entry.body
        <span class="hljs-keyword">this</span>.isLeader = <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>] == <span class="hljs-keyword">this</span>.id
        <span class="hljs-keyword">var</span> properties = entry.properties
        <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.immigrate) {
                <span class="hljs-keyword">var</span> immigrant = <span class="hljs-keyword">this</span>.government.immigrate
                <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.promise == <span class="hljs-string">'1/0'</span>) {
                        <span class="hljs-keyword">this</span>._operate(keyify(<span class="hljs-string">'bootstrap'</span>), [ <span class="hljs-keyword">this</span> ], <span class="hljs-keyword">async</span>())
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (immigrant.id == <span class="hljs-keyword">this</span>.id) {
                        <span class="hljs-keyword">this</span>._operate(keyify(<span class="hljs-string">'join'</span>), [ <span class="hljs-keyword">this</span> ], <span class="hljs-keyword">async</span>())
                    }
                }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">this</span>._operate(keyify(<span class="hljs-string">'immigrate'</span>), [ <span class="hljs-keyword">this</span>, immigrant.id ], <span class="hljs-keyword">async</span>())
                }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"IMMIGRATE"</span>, <span class="hljs-keyword">this</span>.id, immigrant)
                    <span class="hljs-keyword">if</span> (immigrant.id != <span class="hljs-keyword">this</span>.id) {
                        <span class="hljs-keyword">this</span>._backlogs[<span class="hljs-keyword">this</span>.government.promise] = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>._broadcasts))
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.promise != <span class="hljs-string">'1/0'</span>) {
                        <span class="hljs-keyword">this</span>._getBacklog(<span class="hljs-keyword">async</span>())
                    }
                }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'BACKLOGGED'</span>)
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.promise == <span class="hljs-string">'1/0'</span> || immigrant.id == <span class="hljs-keyword">this</span>.id) {
                        <span class="hljs-keyword">this</span>._broadcast(<span class="hljs-literal">true</span>, <span class="hljs-string">'naturalized'</span>, <span class="hljs-keyword">this</span>.government.promise)
                    }
                })
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.government.exile) {
                <span class="hljs-keyword">var</span> exile = <span class="hljs-keyword">this</span>.government.exile
                <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">this</span>._operate(keyify(<span class="hljs-string">'exile'</span>), [ <span class="hljs-keyword">this</span> ], <span class="hljs-keyword">async</span>())
                }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">this</span>.government.exile.promise
                    <span class="hljs-keyword">var</span> broadcasts = []
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>._broadcasts) {
                        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._broadcasts[key].responses[promise]
                        broadcasts.push(<span class="hljs-keyword">this</span>._broadcasts[key])
                    }
                    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._backlogs[promise]
                    <span class="hljs-keyword">async</span>.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">broadcast</span>) </span>{
                        <span class="hljs-keyword">this</span>._checkReduced(broadcast, <span class="hljs-keyword">async</span>())
                    })(broadcasts)
                })
            }
        }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>._operate(keyify(<span class="hljs-string">'government'</span>), [ <span class="hljs-keyword">this</span> ], <span class="hljs-keyword">async</span>())
        })
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.body.body) {</pre></div></div>

        </li>


        <li id="section-20">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Reminder that if you ever want to do queued instead async then the
queue should be external and a property of the object the conference
operates.</p>

            </div>

        </li>


        <li id="section-21">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> envelope = entry.body.body
        <span class="hljs-keyword">switch</span> (envelope.method) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'broadcast'</span>:
            <span class="hljs-keyword">this</span>._broadcasts[envelope.key] = {
                <span class="hljs-attr">key</span>: envelope.key,
                <span class="hljs-attr">internal</span>: envelope.internal,
                <span class="hljs-attr">method</span>: envelope.body.method,
                <span class="hljs-attr">request</span>: envelope.body.body,
                <span class="hljs-attr">responses</span>: {}
            }
            prefix = envelope.internal ? <span class="hljs-string">'!'</span> : <span class="hljs-string">''</span>
            <span class="hljs-keyword">async</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>._operate(keyify(envelope.internal, <span class="hljs-string">'receive'</span>, envelope.body.method), [ <span class="hljs-keyword">this</span>, envelope.body.body ], <span class="hljs-keyword">async</span>())
            }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
                <span class="hljs-keyword">this</span>._write.push({
                    <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
                    <span class="hljs-attr">method</span>: <span class="hljs-string">'reduce'</span>,
                    <span class="hljs-attr">key</span>: envelope.key,
                    <span class="hljs-attr">internal</span>: envelope.internal,
                    <span class="hljs-attr">from</span>: <span class="hljs-keyword">this</span>.government.immigrated.promise[<span class="hljs-keyword">this</span>.id],
                    <span class="hljs-attr">body</span>: response
                })
            })
            <span class="hljs-keyword">break</span></pre></div></div>

        </li>


        <li id="section-22">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Tally our responses and if they match the number of participants,
then invoke the reduction method.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">case</span> <span class="hljs-string">'reduce'</span>:
            <span class="hljs-keyword">var</span> broadcast = <span class="hljs-keyword">this</span>._broadcasts[envelope.key]

            broadcast.responses[envelope.from] = envelope.body


            <span class="hljs-keyword">this</span>._checkReduced(broadcast, <span class="hljs-keyword">async</span>())

            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-string">'naturalized'</span>:
            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._backlogs[envelope.from]
            <span class="hljs-keyword">break</span>
        }
    }
})

Conference.prototype._checkReduced = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, broadcast</span>) </span>{
    <span class="hljs-keyword">var</span> complete = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> promise <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.government.immigrated.id) {
        <span class="hljs-keyword">if</span> (!(promise <span class="hljs-keyword">in</span> broadcast.responses)) {
            complete = <span class="hljs-literal">false</span>
            <span class="hljs-keyword">break</span>
        }
    }

    <span class="hljs-keyword">if</span> (complete) {
        <span class="hljs-keyword">var</span> reduced = []
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> promise <span class="hljs-keyword">in</span> broadcast.responses) {
            reduced.push({
                <span class="hljs-attr">id</span>: <span class="hljs-keyword">this</span>.government.immigrated.id[promise],
                <span class="hljs-attr">value</span>: broadcast.responses[promise]
            })
        }
        <span class="hljs-keyword">this</span>._operate(keyify(broadcast.internal, <span class="hljs-string">'reduced'</span>, broadcast.method), [ reduced, broadcast.request ], <span class="hljs-keyword">async</span>())
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._broadcasts[broadcast.key]
    }
})</pre></div></div>

        </li>


        <li id="section-23">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>TODO Save welcomes, or introductions, and have them expire when the welcome
expires, and maybe that is the entirety of out-of-band.</p>
<p>Any difficulties and this method will return <code>null</code>. Do not return <code>null</code> as
a valid response from your request handler.</p>

            </div>

        </li>


        <li id="section-24">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype.request = cadence(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">async, to, method, body</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length == <span class="hljs-number">3</span>) {
       body = method
       method = to
       to = <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]
    }</pre></div></div>

        </li>


        <li id="section-25">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>TODO More consideration as to what happens when the route <code>to</code> cannot
be found, and whether it makes sense to try to contact anyone but the
leader for initialization.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>._requester.request(<span class="hljs-string">'colleague'</span>, {
        <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
        <span class="hljs-attr">method</span>: <span class="hljs-string">'outOfBand'</span>,
        <span class="hljs-attr">to</span>: to,
        <span class="hljs-attr">body</span>: {
            <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
            <span class="hljs-attr">method</span>: method,
            <span class="hljs-attr">internal</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">body</span>: body
        }
    }, <span class="hljs-keyword">async</span>())
})

Conference.prototype.socket = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">to, header</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length == <span class="hljs-number">1</span>) {
        header = to
        to = <span class="hljs-keyword">this</span>.government.majority[<span class="hljs-number">0</span>]
    }
    <span class="hljs-keyword">var</span> properties = <span class="hljs-keyword">this</span>.getProperties(to)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._client.connect({
        <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
        <span class="hljs-attr">method</span>: <span class="hljs-string">'socket'</span>,
        <span class="hljs-attr">to</span>: properties,
        <span class="hljs-attr">body</span>: header
    })
}</pre></div></div>

        </li>


        <li id="section-26">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Honoring back pressure here, but Iâ€™ve not considered if back pressure is
going to cause deadlock. Iâ€™m sure it can. What happens when the queues
between the parcipants fill?</p>

            </div>

        </li>


        <li id="section-27">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>This bit of code here is disconcerting because it indicates an asynchronous
call back into the system that is waiting for it to complete. At first, I
want to make this call synchronous because we do not want block here.
However, there is still error reporting. We can implement <code>publish</code> so that
it doesnâ€™t necessarily block, give real thought to how we should deal with
stream overflow, and keep a consistent interface. Weâ€™re going to decide that
a high-water mark is unrecoverable, so this call would return an error, and
that error will crash this participant.</p>

            </div>

        </li>


        <li id="section-28">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>Conference.prototype._broadcast = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">internal, method, message</span>) </span>{
    <span class="hljs-keyword">var</span> cookie = <span class="hljs-keyword">this</span>._nextCookie()
    <span class="hljs-keyword">var</span> uniqueId = <span class="hljs-keyword">this</span>.government.immigrated.promise[<span class="hljs-keyword">this</span>.id]
    <span class="hljs-keyword">var</span> key = method + <span class="hljs-string">'['</span> + uniqueId + <span class="hljs-string">']('</span> + cookie + <span class="hljs-string">')'</span>
    <span class="hljs-keyword">this</span>._write.push({
        <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
        <span class="hljs-attr">method</span>: <span class="hljs-string">'broadcast'</span>,
        <span class="hljs-attr">internal</span>: internal,
        <span class="hljs-attr">key</span>: key,
        <span class="hljs-attr">body</span>: {
            <span class="hljs-attr">module</span>: <span class="hljs-string">'conference'</span>,
            <span class="hljs-attr">method</span>: method,
            <span class="hljs-attr">body</span>: message
        }
    })
}

Conference.prototype.broadcast = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method, message</span>) </span>{
    <span class="hljs-keyword">this</span>._broadcast(<span class="hljs-literal">false</span>, method, message)
}

<span class="hljs-built_in">module</span>.exports = Conference</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
